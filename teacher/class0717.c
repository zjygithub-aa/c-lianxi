/*
1.二维数组
    1）.定义：数据类型  数组名[常量][常量]；
        int num[3][4]={1,2,3,4,5,6,7,8,9,10};//定义数组并初始化赋值
        int num[3][4]={0};//这个数组所有元素初始化赋值为0
        int num[3][4]={{1,2},{3,4},{5,6,7,8}};//num[0][0]=1,num[0][1]=2,第0行剩余两个元素值为0 num[1][0]=3,num[1][2]=4,第1行剩余两个元素值为0
        int num[][]={1,2,3,4,5};//不可以这么写
        int num[][3]={1,2,3,4,5};//允许的 也就是说在定义二维数组时，列是必须确定的，数组大小会根据列的大小来决定数组大小 
    2）可以看作是一个几行几列一个矩阵，实际在内存中数据元素的地址是连续的
    3）元素引用
        数组名 [行下标][列下标]；下标从0开始的
    4)在一维数组中，将一维数组看作是多个变量， int arr[10];arr就是首元素的地址 arr<==>&arr[0]，arr+i就是&arr[i] ,*(arr+i)就是arr[i]
            在二维数组中 可以将二维数组看作是多个一维数组，而每一行可以作为一维数组的下标
             int num[3][4]中 ，num[0],num[1],num[2],分别看作是4个一维数组  num[i]:就是&num[i][0]
             因此在二维数组中  num[i]+j  就是 &num[i][j]  
             num[i]看作是一个一维数组的数组名和下标的话  num[i]<==>*(num+i)  因此 *(num+i)+j就是 &num[i][j]那么*(*(num+i)+j)就是num[i][j]
 2.函数：
    1）定义：用来完成一定功能的模块    定义要求：低耦合，高内聚

    2）分类：库函数  和  自定义函数 
    3）函数的组成：函数首部 和函数体     
        函数首部三要素 ：返回值类型   函数名   形参列表
    4）如何定义一个函数
        注意函数的命名：[见名知意]  符合标识符命名规则，命名方式：大驼峰、小驼峰等
        返回值要与返回值类型 一致  如果没有返回值就写void  如果需要结束函数 直接写return就ok了
        参数 一定是圆括号括起来，并且带类型的，注意传参时 类型要一致  形式参数不能赋值
        
        
        返回值类型  函数名 （形式参数列表）
        {
            函数体
        }
    5）函数的调用
        返回值 = 函数名(实际参数列表)；
        实际参数的类型要与形式参数类型一致 ，如果有返回值就可以接收返回值
        函数允许嵌套调用，但是不允许嵌套定义
    6)函数声明
        如果在调用某一个函数时，函数的实现不在调用之前，那么则需要进行函数声明
        格式：返回值类型 函数名 （形参列表）;
    7）全局变量：
        定义在函数外面的，在程序中，所有的函数都可以使用这个变量
    8）局部变量：
        定义在函数内部的，或者符合语句内部，局部变量的作用域只在函数内或者符合语句内
        for(int i=0;i<4;i++);   //变量i 出了循环以后 将不能在使用
        int func(void)
        {
            int a=10;//a的作用域只在func函数内
            return a;
        }
    
    9)函数的定义只能有一次，但是函数声明可以有多次，
    10)函数传参规律：按值传递，函数调用时的参数称为实际参数（实参），函数定义的时的参数称为形式参数（形参）  形参是实参的值拷贝，再参数传递时，只能是单向传递（实参-->形参）
    11）函数递归调用：
        在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用。
        只有能被递归的问题才可以使用递归函数调用，递归调用必须有结束的条件
    函数递归调用包含两个过程：  逐渐递进，逐步回归
    12)exit函数
        调用 return只是代表子函数终止了，在子函数中调用 exit，那么程序终止。  
    13)随机函数
        rand()函数 ：会产生一个随机数
        srand(time(NULL))函数：一般选系统时间作为随机种子  #include <time.h>
3.作用域
    全局变量：定义在函数的外面，作用域：在整个程序，生命周期：整个程序
    局部变量；定义在函数里面或者复合语句内 作用域：函数内部或复合语句内  ，生命周期：调用函数（使用复合语句）期间

    存储类型：自动变量，寄存器变量，静态的，动态的，外部的
    静态变量/函数：static
        静态局部变量：函数调用结束以后会保留上一次的原值 ，只能被初始化赋值1次，作用域：只在函数内，生命周期：从第一次调用--程序结束
        静态全局变量：作用域：只在定义的那个文件  生命周期：整个程序
        静态函数：作用域：只在定义的那个文件  生命周期：整个程序
4.多文件操作
    头文件编写：
            #ifnde 符号
            #define 符号
            //写一些函数/全局变量的生命  或者 结构体类型的声明等
            #endif



    
 */
#include<stdio.h>
#include<stdlib.h>
#include <time.h>
int getage(int n);
void func(void);
void NUM_BOOM(void);
int main(int argc, char const *argv[])
{
     NUM_BOOM();
//    int age=getage(5);
//    printf("第5个学生的年龄为：%d岁\n",age);
//    func();
//    printf("main函数\n");
    return 0;
}
//数字炸弹 游戏  最多只允许猜10次，如果没有猜中也会游戏结束，猜中了输出BOOM,如果10次以后没有猜中输出游戏胜利
void NUM_BOOM(void)
{
    srand(time(NULL));//随机种子
    int num=rand()%100+1;//num作为要谜底  1--100之间
   printf("随机数num：%d\n",num);
    int n=0;//n作为输入猜的数据存储变量
    int max=100,min=1,cnt=0;
    while (n!=num&&cnt<10)//只要没有猜中 就循环
    {
        printf("请猜数%d-%d\n",min,max);
        scanf("%d",&n);
        if(n>num)
        {
            max=n;
            printf("猜大了\n");
        }
        else if(n<num)
        {
            min=n;
            printf("猜小了\n");
        }
        cnt++;
    }
    if(cnt==10&&n!=num)
    {
        printf("胜利了\n");
    }
    else
    printf("BOOM！！！\n");

}
void func(void)
{
    printf("func函数调用\n");
     exit(0);
    //return;
     printf("func函数调用2\n");
}
//函数递归调用  如果n=1  age=10 ,否则 就是前一个人的年龄+2
int getage(int n)
{
    if(n==1)
    {
        return 10;
    }
    //否则 
    return getage(n-1)+2;


}
#if 0 

#include <stdio.h>
#include<string.h>
/*5个学生4门课程，要求输入学生成绩，求每个学生的平均分和每门课程平均分，以及2门以上不及格的学生的序号 以及平均分在80分以上的学生的序号 通过函数来完成*/
float score[5][4]=
{
    89,90,88,87,//每一行为一个学生的成绩
    89,65,53,32,
    64,75,90,75,
    74,86,87,88,
    47,47,57,57
};
float stu_avg[5]={0},sub_avg[4]={0};
//函数声明
//求某一门课程平均分
float get_sub_avg(int n);
void test2(void);
//求2门以上不及格的学生 要求输出序号 （序号从1开始编号）
void test3(void);
//平均分在80分以上的学生的序号
void test4(void);
//定义一个函数  求某一个学生的平均分
float get_stu_avg(int n)
{
    float avg=0;
    //每个学生有4门课程的
    for(int j=0;j<4;j++)
    {
    avg+=score[n-1][j];//所有的课程分数累加
    }
    //返回平均分
    return avg/4;
}
//第一问
void test1(void)
{
    //1.每个学生的平均分
    printf(" 每个学生的平均分:");
    for(int i=0;i<5;i++)
    {
        stu_avg[i]=get_stu_avg(i+1);//从1开始编号  但是数组中下标从0开始
        printf("%.2f\t",stu_avg[i]);
    }
    printf("\n");
}
int main(int argc, char const *argv[])
{
  //函数调用
    test1();
    test2();
    test3();
    test4();
    return 0;
}

//求某一门课程平均分
float get_sub_avg(int n)
{
    float avg=0;
    //每4门课程有5个学生
    for(int j=0;j<5;j++)
    {
        avg+=score[j][n-1];//所有的学生分数累加
    }
    //返回平均分
    return avg/5;
}
//第二问
void test2(void)
{
       //1. 每门课程的平均分
      printf(" 每门课程的平均分:");
       for(int i=0;i<4;i++)
       {
        sub_avg[i]=get_sub_avg(i+1);//从1开始编号  但是数组中下标从0开始
        printf("%.2f\t",sub_avg[i]);
       }
       printf("\n");

}
//求2门以上不及格的学生 要求输出序号 （序号从1开始编号）
void test3(void)
{
    int i,j,cnt=0;//cnt:计数
    for(i=0;i<5;i++)
    {
        cnt=0;//没更新一个学生 不及格门数就要重新计数
        for(j=0;j<4;j++)
        {
            //如果某个学生成绩低于60分 就进行计数
            if(score[i][j]<60)
            {
                cnt++;
            }
        }
        //此时一个学生的不及格的门数已经统计完了
        if(cnt>=2)
        {
            printf("2门以上不及格的学生是：%d号\n",i+1);
        }
    }

}
//平均分在80分以上的学生的序号
void test4(void)
{
    //由于在第1问中 已经将所有的学生成绩的平均分计算出来并保存 ，那么此时可以直接使用数组  stu_avg
    for(int i=0;i<5;i++)
    {
       // if(get_stu_avg(i+1)>=80)
       if(stu_avg[i]>=80)
        {
            printf("平均分在80分以上的同学是：%d号\n",i+1);
        }
    }
}


//二维数组
int main(int argc, char const *argv[])
{
    int num[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};//第一个方括号作为行，第二个方括号作为列
    for(int i=0;i<3;i++)
    {
        for(int j=0;j<4;j++)
        {
           // printf("%d ",num[i][j]);
            printf("&num[%d][%d]:%p\t",i,j,&num[i][j]);
        }
        printf("\n");
    }
     printf("-----------------\n");
     for(int i=0;i<3;i++)
     {
        printf("%p\n",num[i]);//num[i]就是&num[i][0]
     }
    printf("-----------------\n");
    for(int i=0;i<3;i++)
    {
        for(int j=0;j<4;j++)
        {
           // printf("%d ",num[i][j]);
            printf("%p\t",num[i]+j);
        }
        printf("\n");
    }
    //数组初始化赋值的定义
    // int arr[][4]={1,2,3,4,5,6,7,8,9};//实际数据长度为9个   9/4=2 余1   所以需要3行   3*4*4=48
    // printf("arr size:%lu\n",sizeof(arr));
    // for(int i=0;i<3;i++)
    // {
    //     for(int j=0;j<4;j++)
    //     {
    //         printf("%d ",arr[i][j]);
            
    //     }
    //     printf("\n");
    // }

    // //-----------------
    // printf("-----------------\n");
    // int array[3][4]={{1,2},{3,4},{5,6,7,8}};
    //  for(int i=0;i<3;i++)
    // {
    //     for(int j=0;j<4;j++)
    //     {
    //         printf("%d ",array[i][j]);
            
    //     }
    //     printf("\n");
    // }
    return 0;
}

#endif